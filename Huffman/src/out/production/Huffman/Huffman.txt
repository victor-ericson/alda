För att börja implementera min komprimering och dekomprimering med hjälp av Huffmankodning valde jag att fokusera på komprimeraren. För att sortera alla tecken utifrån vad som är mest frekvent förekommande valde att skapa en HashMap, som mappar varje givet tecken i en sträng till ett int-värde. Jag itererar sedan genom varje tecken i strängen och, om tecknet redan finns adderar jag +1 till tecknets värde. Alternativt om det ännu inte mappats så lägger jag till tecknet i mappen med tillhörande värde 1 som startvärde.

Först efter detta konstruerar jag mitt Huffmanträd. Jag börjar med att skapa en priority queue då denna kö tillåter oss att sortera tecknen på prioritet (och därmed även frekvens).  Då konstruktionen av ett Huffmanträd bygger på att dedikera minsta möjliga bitar till de mest frekvent förekommande tecknen i en sträng för att vår bitkod ska bli så liten som möjligt så lämpar sig denna datastruktur bra. För att konstruera vårt träd går jag successivt igenom varje nod, tar bort de noder som har lägst frekvens (således högst prioritet), skapar en ny intern nod med de två noderna som barn och sätter frekvensen av noden som summan av de två nodernas frekvenser (observera att frekvenssummeringen görs i konstruktorn för noden, inte direkt i while-loopen).

Efter detta är klart skapar jag en ny HashMap som ska husera tecknens alla bitkoder. Jag populerar sedan mappen med hjälp av min metod generateCodes (lokaliserad i nodklassen) som rekursivt skapar koder för varje nod. Metoden fungerar genom att rekursivt addera antingen en 0:a eller en 1:a till vår kodsträng. Om den nuvarande noden är en lövnod mappar jag den konstruerade kodsträngen till det aktuella tecknet. Om noden inte är ett löv anropar jag metoden både för det vänstra och det högra barnet, med vår hittills konstruerade sträng plus en 0:a givet att det är vänster barn och en 1:a givet att det är höger barn jag anropar. På så sätt så byggs successivt en bitsträng upp för varje tecken.

I slutet av metoden encode returnerar jag ett nytt EncodedMessage med vårt Huffmanträd och en sträng som är vårt meddelande representerat som en bitsträng.

För att sen avkoda detta meddelande anropas decode som tar in vårt meddelande och vårt Huffmanträd som parametrar. Metoden går sedan rekursivt igenom vår sträng för att avkoda meddelandet. Rekursionen fungerar på så sätt att den tittar på en bit i taget. Om biten är en 0:a så sätter den vår nod (vårt Huffmanträd) till node.left och därmed går jag rekursivt igenom vänstra delen av trädet. Om biten är en 1:a sätter jag vår nod till node.right och går därmed rekursivt igenom högra delen av trädet. Om noden visar sig vara ett löv så har jag, per ett Huffmanträds regler, hittat ett tecken. Jag lägger sedan till nodens tecken till vår avkodade sträng och sätter noden till roten, och går sedan vidare genom vår bitsträng. När detta är gjort för samtliga tecken i vår bitsträng returnerar jag det kompletta avkodade meddelandet.